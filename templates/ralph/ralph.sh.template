#!/bin/bash
#
# RALPH - Autonomous AI Development Loop
# Inspired by Ralphy (github.com/michaelshimeles/ralphy)
#
# Two Modes:
#   1. Single Task (Brownfield): ./ralph.sh "add dark mode"
#   2. PRD Loop (Greenfield):    ./ralph.sh [max_iterations]
#
# Features:
#   - Sequential and parallel execution
#   - Branch-per-task workflow with auto-merge
#   - Configurable quality gates
#   - Multi-AI engine support (Claude Code default)
#   - Retry logic with exponential backoff
#   - Progress tracking and cost reporting
#
# Requirements:
#   - Claude Code CLI installed and authenticated
#   - jq installed (brew install jq / apt install jq)
#   - Git repository initialized
#   - prd.json or PRD.md with tasks
#

set -euo pipefail

# ============================================
# CONFIGURATION & DEFAULTS
# ============================================

VERSION="2.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Ralph config directory
RALPH_DIR=".ralph"
PROGRESS_FILE="$RALPH_DIR/progress.txt"
CONFIG_FILE="$RALPH_DIR/config.yaml"
SINGLE_TASK=""
INIT_MODE=false
SHOW_CONFIG=false
ADD_RULE=""
AUTO_COMMIT=true

# Runtime options
SKIP_TESTS=false
SKIP_LINT=false
AI_ENGINE="claude"
MODEL_OVERRIDE=""
DRY_RUN=false
MAX_ITERATIONS="${1:-0}"  # 0 = unlimited when running PRD
MAX_RETRIES=3
RETRY_DELAY=5
VERBOSE=false

# Git branch options
BRANCH_PER_TASK=false
CREATE_PR=false
BASE_BRANCH=""
PR_DRAFT=false

# Parallel execution
PARALLEL=false
MAX_PARALLEL=3

# PRD source options
PRD_SOURCE="auto"  # auto, markdown, yaml, json
PRD_FILE=""

# Colors (detect if terminal supports colors)
if [[ -t 1 ]] && command -v tput &>/dev/null && [[ $(tput colors 2>/dev/null || echo 0) -ge 8 ]]; then
  RED=$(tput setaf 1)
  GREEN=$(tput setaf 2)
  YELLOW=$(tput setaf 3)
  BLUE=$(tput setaf 4)
  MAGENTA=$(tput setaf 5)
  CYAN=$(tput setaf 6)
  BOLD=$(tput bold)
  DIM=$(tput dim)
  RESET=$(tput sgr0)
else
  RED="" GREEN="" YELLOW="" BLUE="" MAGENTA="" CYAN="" BOLD="" DIM="" RESET=""
fi

# Global state
total_input_tokens=0
total_output_tokens=0
total_cost="0"
iteration=0
declare -a task_branches=()

# ============================================
# UTILITY FUNCTIONS
# ============================================

log_info() { echo -e "${BLUE}[RALPH]${RESET} $*"; }
log_success() { echo -e "${GREEN}[RALPH]${RESET} $*"; }
log_warn() { echo -e "${YELLOW}[RALPH]${RESET} $*"; }
log_error() { echo -e "${RED}[RALPH]${RESET} $*" >&2; }
log_debug() { [[ "$VERBOSE" == true ]] && echo -e "${DIM}[DEBUG] $*${RESET}"; }

# Slugify text for branch names
slugify() {
  echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-|-$//g' | cut -c1-50
}

# ============================================
# CONFIGURATION MANAGEMENT
# ============================================

# Initialize .ralph/ directory with config files
init_ralph_config() {
  if [[ -d "$PROJECT_DIR/$RALPH_DIR" ]]; then
    log_warn "$RALPH_DIR already exists"
    read -p "Overwrite config? [y/N] " -n 1 -r
    echo
    [[ ! $REPLY =~ ^[Yy]$ ]] && exit 0
  fi

  mkdir -p "$PROJECT_DIR/$RALPH_DIR"

  # Smart detection
  local project_name lang framework test_cmd lint_cmd build_cmd typecheck_cmd
  project_name=$(basename "$PROJECT_DIR")

  if [[ -f "$PROJECT_DIR/package.json" ]]; then
    local pkg_name
    pkg_name=$(jq -r '.name // ""' "$PROJECT_DIR/package.json" 2>/dev/null)
    [[ -n "$pkg_name" ]] && project_name="$pkg_name"

    # Detect language
    if [[ -f "$PROJECT_DIR/tsconfig.json" ]]; then
      lang="TypeScript"
      typecheck_cmd="npx tsc --noEmit"
    else
      lang="JavaScript"
      typecheck_cmd=""
    fi

    # Detect frameworks
    local deps frameworks=()
    deps=$(jq -r '(.dependencies // {}) + (.devDependencies // {}) | keys[]' "$PROJECT_DIR/package.json" 2>/dev/null || true)
    echo "$deps" | grep -qx "next" && frameworks+=("Next.js")
    echo "$deps" | grep -qx "react" && [[ ${#frameworks[@]} -eq 0 ]] && frameworks+=("React")
    echo "$deps" | grep -qx "express" && frameworks+=("Express")
    framework=$(IFS=', '; echo "${frameworks[*]}")

    # Detect commands
    local scripts
    scripts=$(jq -r '.scripts // {}' "$PROJECT_DIR/package.json" 2>/dev/null)
    echo "$scripts" | jq -e '.test' >/dev/null 2>&1 && test_cmd="npm test"
    echo "$scripts" | jq -e '.lint' >/dev/null 2>&1 && lint_cmd="npm run lint"
    echo "$scripts" | jq -e '.build' >/dev/null 2>&1 && build_cmd="npm run build"
    echo "$scripts" | jq -e '.typecheck' >/dev/null 2>&1 && typecheck_cmd="npm run typecheck"

  elif [[ -f "$PROJECT_DIR/pyproject.toml" ]] || [[ -f "$PROJECT_DIR/requirements.txt" ]]; then
    lang="Python"
    test_cmd="pytest"
    lint_cmd="ruff check ."
    typecheck_cmd="mypy ."

  elif [[ -f "$PROJECT_DIR/go.mod" ]]; then
    lang="Go"
    test_cmd="go test ./..."
    lint_cmd="golangci-lint run"
    build_cmd="go build ./..."
    typecheck_cmd=""
  fi

  # Show detection results
  echo ""
  echo "${BOLD}Detected:${RESET}"
  echo "  Project:   ${CYAN}$project_name${RESET}"
  [[ -n "$lang" ]] && echo "  Language:  ${CYAN}$lang${RESET}"
  [[ -n "$framework" ]] && echo "  Framework: ${CYAN}$framework${RESET}"
  [[ -n "$test_cmd" ]] && echo "  Test:      ${CYAN}$test_cmd${RESET}"
  [[ -n "$lint_cmd" ]] && echo "  Lint:      ${CYAN}$lint_cmd${RESET}"
  [[ -n "$typecheck_cmd" ]] && echo "  Typecheck: ${CYAN}$typecheck_cmd${RESET}"
  echo ""

  # Create config.yaml
  cat > "$PROJECT_DIR/$CONFIG_FILE" << EOF
# RALPH Configuration
# Generated by ralph.sh --init

# Project info (auto-detected)
project:
  name: "$project_name"
  language: "${lang:-Unknown}"
  framework: "${framework:-}"
  description: ""

# Quality gate commands
commands:
  test: "${test_cmd:-}"
  lint: "${lint_cmd:-}"
  typecheck: "${typecheck_cmd:-}"
  build: "${build_cmd:-}"

# Rules - instructions the AI MUST follow
# These are injected into every prompt
rules: []
  # Examples:
  # - "Always use TypeScript strict mode"
  # - "Follow the error handling pattern in src/utils/errors.ts"
  # - "Use server actions instead of API routes in Next.js"

# Boundaries - files/folders the AI should NOT modify
boundaries:
  never_touch: []
    # Examples:
    # - "src/legacy/**"
    # - "migrations/**"
    # - "*.lock"

# Execution settings
settings:
  max_retries: 3
  retry_delay: 5
  auto_commit: true
EOF

  # Create progress.txt
  cat > "$PROJECT_DIR/$PROGRESS_FILE" << EOF
# RALPH Progress Log

Started: $(date '+%Y-%m-%d')
Project: $project_name

## Codebase Patterns
(Patterns will be discovered and added during iterations)

---

EOF

  log_success "Created $RALPH_DIR/"
  echo "  ${CYAN}$CONFIG_FILE${RESET}   - Your rules and preferences"
  echo "  ${CYAN}$PROGRESS_FILE${RESET} - Progress log"
  echo ""
  echo "${BOLD}Next steps:${RESET}"
  echo "  1. Edit rules:  ${CYAN}vim $CONFIG_FILE${RESET}"
  echo "  2. Create PRD:  ${CYAN}/prd [feature description]${RESET}"
  echo "  3. Run RALPH:   ${CYAN}./scripts/ralph/ralph.sh 20${RESET}"
}

# Load rules from config.yaml
load_ralph_rules() {
  [[ ! -f "$PROJECT_DIR/$CONFIG_FILE" ]] && return
  if command -v yq &>/dev/null; then
    yq -r '.rules // [] | .[]' "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null || true
  fi
}

# Load boundaries from config.yaml
load_ralph_boundaries() {
  [[ ! -f "$PROJECT_DIR/$CONFIG_FILE" ]] && return
  if command -v yq &>/dev/null; then
    yq -r '.boundaries.never_touch // [] | .[]' "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null || true
  fi
}

# Load project context from config.yaml
load_project_context() {
  [[ ! -f "$PROJECT_DIR/$CONFIG_FILE" ]] && return
  if command -v yq &>/dev/null; then
    local name lang framework desc
    name=$(yq -r '.project.name // ""' "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null)
    lang=$(yq -r '.project.language // ""' "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null)
    framework=$(yq -r '.project.framework // ""' "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null)
    desc=$(yq -r '.project.description // ""' "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null)

    local context=""
    [[ -n "$name" ]] && context+="Project: $name\n"
    [[ -n "$lang" ]] && context+="Language: $lang\n"
    [[ -n "$framework" ]] && context+="Framework: $framework\n"
    [[ -n "$desc" ]] && context+="Description: $desc\n"
    echo -e "$context"
  fi
}

# Load commands from config.yaml
load_commands() {
  local cmd_type="$1"
  [[ ! -f "$PROJECT_DIR/$CONFIG_FILE" ]] && return
  if command -v yq &>/dev/null; then
    yq -r ".commands.$cmd_type // \"\"" "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null || echo ""
  fi
}

# Show current config
show_ralph_config() {
  if [[ ! -f "$PROJECT_DIR/$CONFIG_FILE" ]]; then
    log_warn "No config found. Run 'ralph.sh --init' first."
    exit 1
  fi

  echo ""
  echo "${BOLD}RALPH Configuration${RESET} ($CONFIG_FILE)"
  echo ""

  if command -v yq &>/dev/null; then
    local name lang framework
    name=$(yq -r '.project.name // "Unknown"' "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null)
    lang=$(yq -r '.project.language // "Unknown"' "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null)
    framework=$(yq -r '.project.framework // ""' "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null)

    echo "${BOLD}Project:${RESET}"
    echo "  Name:      $name"
    echo "  Language:  $lang"
    [[ -n "$framework" ]] && echo "  Framework: $framework"
    echo ""

    echo "${BOLD}Commands:${RESET}"
    for cmd in test lint typecheck build; do
      local val
      val=$(yq -r ".commands.$cmd // \"\"" "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null)
      printf "  %-10s %s\n" "$cmd:" "${val:-${DIM}(not set)${RESET}}"
    done
    echo ""

    echo "${BOLD}Rules:${RESET}"
    local rules
    rules=$(yq -r '.rules // [] | .[]' "$PROJECT_DIR/$CONFIG_FILE" 2>/dev/null)
    if [[ -n "$rules" ]]; then
      echo "$rules" | while read -r rule; do
        echo "  - $rule"
      done
    else
      echo "  ${DIM}(none)${RESET}"
    fi
    echo ""
  else
    cat "$PROJECT_DIR/$CONFIG_FILE"
  fi
}

# Log task to progress file
log_task_history() {
  local task="$1"
  local status="$2"  # completed, failed

  [[ ! -f "$PROJECT_DIR/$PROGRESS_FILE" ]] && return

  local timestamp icon
  timestamp=$(date '+%Y-%m-%d %H:%M')
  icon="[+]"
  [[ "$status" == "failed" ]] && icon="[x]"

  echo "- $icon $timestamp - $task" >> "$PROJECT_DIR/$PROGRESS_FILE"
}

# ============================================
# PRD SOURCE DETECTION
# ============================================

detect_prd_source() {
  # Check for prd.json first (our native format)
  if [[ -f "$PROJECT_DIR/prd.json" ]]; then
    PRD_SOURCE="json"
    PRD_FILE="prd.json"
    return
  fi

  # Check for PRD.md (markdown format)
  if [[ -f "$PROJECT_DIR/PRD.md" ]]; then
    PRD_SOURCE="markdown"
    PRD_FILE="PRD.md"
    return
  fi

  # Check for tasks.yaml
  if [[ -f "$PROJECT_DIR/tasks.yaml" ]]; then
    PRD_SOURCE="yaml"
    PRD_FILE="tasks.yaml"
    return
  fi

  log_error "No PRD found. Create one with:"
  echo "  - /prd [feature description]  (creates prd.json)"
  echo "  - PRD.md with tasks:           - [ ] Task description"
  echo "  - tasks.yaml with YAML format"
  exit 1
}

# ============================================
# TASK MANAGEMENT
# ============================================

# Get next task from PRD source
get_next_task() {
  case "$PRD_SOURCE" in
    json)
      jq -r '.userStories[] | select(.passes == false) | "\(.id): \(.title)"' "$PROJECT_DIR/$PRD_FILE" 2>/dev/null | head -1
      ;;
    markdown)
      grep -E '^\s*-\s*\[ \]' "$PROJECT_DIR/$PRD_FILE" 2>/dev/null | head -1 | sed 's/^\s*-\s*\[ \]\s*//'
      ;;
    yaml)
      if command -v yq &>/dev/null; then
        yq -r '.tasks[] | select(.completed == false) | .title' "$PROJECT_DIR/$PRD_FILE" 2>/dev/null | head -1
      fi
      ;;
  esac
}

# Count remaining tasks
count_remaining() {
  case "$PRD_SOURCE" in
    json)
      jq '[.userStories[] | select(.passes == false)] | length' "$PROJECT_DIR/$PRD_FILE" 2>/dev/null || echo "0"
      ;;
    markdown)
      grep -cE '^\s*-\s*\[ \]' "$PROJECT_DIR/$PRD_FILE" 2>/dev/null || echo "0"
      ;;
    yaml)
      if command -v yq &>/dev/null; then
        yq '[.tasks[] | select(.completed == false)] | length' "$PROJECT_DIR/$PRD_FILE" 2>/dev/null || echo "0"
      else
        echo "0"
      fi
      ;;
  esac
}

# Count completed tasks
count_completed() {
  case "$PRD_SOURCE" in
    json)
      jq '[.userStories[] | select(.passes == true)] | length' "$PROJECT_DIR/$PRD_FILE" 2>/dev/null || echo "0"
      ;;
    markdown)
      grep -cE '^\s*-\s*\[x\]' "$PROJECT_DIR/$PRD_FILE" 2>/dev/null || echo "0"
      ;;
    yaml)
      if command -v yq &>/dev/null; then
        yq '[.tasks[] | select(.completed == true)] | length' "$PROJECT_DIR/$PRD_FILE" 2>/dev/null || echo "0"
      else
        echo "0"
      fi
      ;;
  esac
}

# Mark task complete
mark_task_complete() {
  local task="$1"

  case "$PRD_SOURCE" in
    json)
      # Update passes: true for the task by ID or title
      local task_id
      task_id=$(echo "$task" | cut -d: -f1 | tr -d ' ')
      jq --arg id "$task_id" '(.userStories[] | select(.id == $id)).passes = true' "$PROJECT_DIR/$PRD_FILE" > "$PROJECT_DIR/$PRD_FILE.tmp" \
        && mv "$PROJECT_DIR/$PRD_FILE.tmp" "$PROJECT_DIR/$PRD_FILE"
      ;;
    markdown)
      # Change "- [ ]" to "- [x]" for matching task
      local escaped_task
      escaped_task=$(echo "$task" | sed 's/[[\.*^$()+?{|]/\\&/g')
      sed -i.bak "s/^\(\s*\)- \[ \]\s*${escaped_task}/\1- [x] ${task}/" "$PROJECT_DIR/$PRD_FILE"
      rm -f "$PROJECT_DIR/$PRD_FILE.bak"
      ;;
    yaml)
      if command -v yq &>/dev/null; then
        yq -i "(.tasks[] | select(.title == \"$task\")).completed = true" "$PROJECT_DIR/$PRD_FILE"
      fi
      ;;
  esac
}

# ============================================
# PROMPT BUILDING
# ============================================

build_prompt() {
  local task_override="${1:-}"
  local prompt=""

  # Add project context if available
  local context
  context=$(load_project_context)
  if [[ -n "$context" ]]; then
    prompt+="## Project Context
$context

"
  fi

  # Add rules if available
  local rules
  rules=$(load_ralph_rules)
  if [[ -n "$rules" ]]; then
    prompt+="## Rules (you MUST follow these)
$rules

"
  fi

  # Add boundaries
  local boundaries
  boundaries=$(load_ralph_boundaries)
  if [[ -n "$boundaries" ]]; then
    prompt+="## Boundaries - Do NOT modify these files:
$boundaries

"
  fi

  # Add quality gate commands
  local test_cmd lint_cmd typecheck_cmd
  test_cmd=$(load_commands "test")
  lint_cmd=$(load_commands "lint")
  typecheck_cmd=$(load_commands "typecheck")

  if [[ -n "$test_cmd" ]] || [[ -n "$lint_cmd" ]] || [[ -n "$typecheck_cmd" ]]; then
    prompt+="## Quality Gate Commands
"
    [[ -n "$typecheck_cmd" ]] && prompt+="- Typecheck: $typecheck_cmd
"
    [[ -n "$lint_cmd" ]] && prompt+="- Lint: $lint_cmd
"
    [[ -n "$test_cmd" ]] && prompt+="- Test: $test_cmd

"
  fi

  # Reference the PRD and progress files
  prompt+="## Task Source
Read the PRD file and select the highest-priority incomplete task:
@$PRD_FILE @$PROGRESS_FILE

"

  # Build instructions
  prompt+="## Instructions
1. Find the highest-priority incomplete task and implement it."

  local step=2

  if [[ "$SKIP_TESTS" == false ]] && [[ -n "$test_cmd" ]]; then
    prompt+="
$step. Write tests for the feature.
$((step+1)). Run tests ($test_cmd) and ensure they pass."
    step=$((step+2))
  fi

  if [[ "$SKIP_LINT" == false ]] && [[ -n "$lint_cmd" ]]; then
    prompt+="
$step. Run linting ($lint_cmd) and ensure it passes."
    step=$((step+1))
  fi

  if [[ -n "$typecheck_cmd" ]]; then
    prompt+="
$step. Run typecheck ($typecheck_cmd) and ensure it passes."
    step=$((step+1))
  fi

  # Task completion based on source
  case "$PRD_SOURCE" in
    json)
      prompt+="
$step. Update $PRD_FILE to mark the task as complete (set passes: true)."
      ;;
    markdown)
      prompt+="
$step. Update $PRD_FILE to mark the task as complete (change '- [ ]' to '- [x]')."
      ;;
    yaml)
      prompt+="
$step. Update $PRD_FILE to mark the task as completed (set completed: true)."
      ;;
  esac

  step=$((step+1))

  prompt+="
$step. Append your progress to $PROGRESS_FILE with learnings.
$((step+1)). Commit your changes with a descriptive message.

ONLY WORK ON A SINGLE TASK."

  if [[ "$SKIP_TESTS" == false ]] && [[ -n "$test_cmd" ]]; then
    prompt+=" Do not proceed if tests fail."
  fi
  if [[ "$SKIP_LINT" == false ]] && [[ -n "$lint_cmd" ]]; then
    prompt+=" Do not proceed if linting fails."
  fi

  prompt+="

If ALL tasks in the PRD are complete, output <promise>COMPLETE</promise>."

  echo "$prompt"
}

# Build brownfield (single-task) prompt
build_brownfield_prompt() {
  local task="$1"
  local prompt=""

  # Add project context if available
  local context
  context=$(load_project_context)
  if [[ -n "$context" ]]; then
    prompt+="## Project Context
$context

"
  fi

  # Add rules if available
  local rules
  rules=$(load_ralph_rules)
  if [[ -n "$rules" ]]; then
    prompt+="## Rules (you MUST follow these)
$rules

"
  fi

  # Add boundaries
  local boundaries
  boundaries=$(load_ralph_boundaries)
  if [[ -n "$boundaries" ]]; then
    prompt+="## Boundaries - Do NOT modify these files:
$boundaries

"
  fi

  # Add the task
  prompt+="## Task
$task

## Instructions
1. Implement the task described above
2. Write tests if appropriate
3. Ensure the code works correctly"

  if [[ "$AUTO_COMMIT" == "true" ]]; then
    prompt+="
4. Commit your changes with a descriptive message"
  fi

  prompt+="

Keep changes focused and minimal. Do not refactor unrelated code."

  echo "$prompt"
}

# ============================================
# AI ENGINE EXECUTION
# ============================================

run_ai_command() {
  local prompt=$1
  local output_file=$2

  case "$AI_ENGINE" in
    claude)
      claude --dangerously-skip-permissions \
        ${MODEL_OVERRIDE:+--model "$MODEL_OVERRIDE"} \
        --verbose \
        --output-format stream-json \
        -p "$prompt" > "$output_file" 2>&1
      ;;
    *)
      log_error "Unknown AI engine: $AI_ENGINE"
      exit 1
      ;;
  esac
}

parse_ai_result() {
  local result=$1
  local response=""
  local input_tokens=0
  local output_tokens=0

  # Parse Claude Code stream-json output
  local result_line
  result_line=$(echo "$result" | grep '"type":"result"' | tail -1)

  if [[ -n "$result_line" ]]; then
    response=$(echo "$result_line" | jq -r '.result // "No result text"' 2>/dev/null || echo "Could not parse result")
    input_tokens=$(echo "$result_line" | jq -r '.usage.input_tokens // 0' 2>/dev/null || echo "0")
    output_tokens=$(echo "$result_line" | jq -r '.usage.output_tokens // 0' 2>/dev/null || echo "0")
  fi

  [[ "$input_tokens" =~ ^[0-9]+$ ]] || input_tokens=0
  [[ "$output_tokens" =~ ^[0-9]+$ ]] || output_tokens=0

  echo "$response"
  echo "---TOKENS---"
  echo "$input_tokens"
  echo "$output_tokens"
}

check_for_errors() {
  local result=$1

  if echo "$result" | grep -q '"type":"error"'; then
    local error_msg
    error_msg=$(echo "$result" | grep '"type":"error"' | head -1 | jq -r '.error.message // .message // "Unknown error"' 2>/dev/null || echo "Unknown error")
    echo "$error_msg"
    return 1
  fi

  return 0
}

# ============================================
# SINGLE TASK EXECUTION
# ============================================

run_single_task() {
  local task_name="${1:-}"
  local task_num="${2:-$iteration}"
  local retry_count=0

  echo ""
  echo "${BOLD}>>> Task $task_num${RESET}"

  local remaining completed
  remaining=$(count_remaining | tr -d '[:space:]')
  completed=$(count_completed | tr -d '[:space:]')
  remaining=${remaining:-0}
  completed=${completed:-0}
  echo "${DIM}    Completed: $completed | Remaining: $remaining${RESET}"
  echo "────────────────────────────────────────────────"

  # Get current task
  local current_task
  if [[ -n "$task_name" ]]; then
    current_task="$task_name"
  else
    current_task=$(get_next_task)
  fi

  if [[ -z "$current_task" ]]; then
    log_info "No more tasks found"
    return 2
  fi

  echo "  ${CYAN}$current_task${RESET}"
  echo ""

  # Create branch if needed
  local branch_name=""
  if [[ "$BRANCH_PER_TASK" == true ]]; then
    branch_name="ralph/$(slugify "$current_task")"
    git checkout -b "$branch_name" 2>/dev/null || git checkout "$branch_name" 2>/dev/null || true
    task_branches+=("$branch_name")
    log_info "Working on branch: $branch_name"
  fi

  # Temp file for AI output
  local tmpfile
  tmpfile=$(mktemp)

  # Build the prompt
  local prompt
  prompt=$(build_prompt "$current_task")

  if [[ "$DRY_RUN" == true ]]; then
    log_info "DRY RUN - Would execute prompt:"
    echo "${DIM}$prompt${RESET}"
    rm -f "$tmpfile"
    return 0
  fi

  # Run with retry logic
  while [[ $retry_count -lt $MAX_RETRIES ]]; do
    log_info "Running AI agent..."

    run_ai_command "$prompt" "$tmpfile"

    # Read result
    local result
    result=$(cat "$tmpfile" 2>/dev/null || echo "")

    # Check for empty response
    if [[ -z "$result" ]]; then
      ((retry_count++)) || true
      log_error "Empty response (attempt $retry_count/$MAX_RETRIES)"
      if [[ $retry_count -lt $MAX_RETRIES ]]; then
        log_info "Retrying in ${RETRY_DELAY}s..."
        sleep "$RETRY_DELAY"
        continue
      fi
      rm -f "$tmpfile"
      return 1
    fi

    # Check for API errors
    local error_msg
    if ! error_msg=$(check_for_errors "$result"); then
      ((retry_count++)) || true
      log_error "API error: $error_msg (attempt $retry_count/$MAX_RETRIES)"
      if [[ $retry_count -lt $MAX_RETRIES ]]; then
        log_info "Retrying in ${RETRY_DELAY}s..."
        sleep "$RETRY_DELAY"
        continue
      fi
      rm -f "$tmpfile"
      return 1
    fi

    # Parse the result
    local parsed response
    parsed=$(parse_ai_result "$result")
    response=$(echo "$parsed" | sed '/^---TOKENS---$/,$d')

    local input_tokens output_tokens
    input_tokens=$(echo "$parsed" | sed -n '/^---TOKENS---$/,$ p' | sed -n '2p')
    output_tokens=$(echo "$parsed" | sed -n '/^---TOKENS---$/,$ p' | sed -n '3p')

    # Update totals
    total_input_tokens=$((total_input_tokens + input_tokens))
    total_output_tokens=$((total_output_tokens + output_tokens))

    log_success "Task completed"
    log_debug "Tokens: $input_tokens in / $output_tokens out"

    # Log to history
    log_task_history "$current_task" "completed"

    # Create PR if requested
    if [[ "$CREATE_PR" == true ]] && [[ -n "$branch_name" ]] && [[ -n "$BASE_BRANCH" ]]; then
      if command -v gh &>/dev/null; then
        gh pr create --base "$BASE_BRANCH" --head "$branch_name" \
          --title "feat: $current_task" \
          --body "Automated PR created by RALPH" \
          ${PR_DRAFT:+--draft} || true
      fi
    fi

    rm -f "$tmpfile"

    # Check for completion signal
    if echo "$result" | grep -q "<promise>COMPLETE</promise>"; then
      log_success "All tasks complete signal received"
      return 2
    fi

    return 0
  done

  rm -f "$tmpfile"
  log_task_history "$current_task" "failed"
  return 1
}

# Run brownfield (single task) mode
run_brownfield_task() {
  local task="$1"

  echo ""
  echo "${BOLD}════════════════════════════════════════════════════════════${RESET}"
  echo "${BOLD}RALPH${RESET} - Single Task Mode"
  echo "${BOLD}════════════════════════════════════════════════════════════${RESET}"
  echo ""
  echo "  Task: ${CYAN}$task${RESET}"
  echo ""

  local prompt
  prompt=$(build_brownfield_prompt "$task")

  local tmpfile
  tmpfile=$(mktemp)

  log_info "Running AI agent..."

  run_ai_command "$prompt" "$tmpfile"

  local result
  result=$(cat "$tmpfile" 2>/dev/null || echo "")

  if [[ -z "$result" ]]; then
    log_error "Empty response from AI"
    rm -f "$tmpfile"
    return 1
  fi

  local error_msg
  if ! error_msg=$(check_for_errors "$result"); then
    log_error "AI error: $error_msg"
    rm -f "$tmpfile"
    return 1
  fi

  log_success "Task completed"
  log_task_history "$task" "completed"

  rm -f "$tmpfile"
  return 0
}

# ============================================
# COST CALCULATION
# ============================================

calculate_cost() {
  local input=$1
  local output=$2

  if command -v bc &>/dev/null; then
    echo "scale=4; ($input * 0.000003) + ($output * 0.000015)" | bc
  else
    echo "N/A"
  fi
}

# ============================================
# SUMMARY
# ============================================

show_summary() {
  echo ""
  echo "${BOLD}════════════════════════════════════════════════════════════${RESET}"
  echo "${GREEN}RALPH Complete!${RESET} Finished $iteration task(s)."
  echo "${BOLD}════════════════════════════════════════════════════════════${RESET}"
  echo ""
  echo "${BOLD}>>> Cost Summary${RESET}"
  echo "Input tokens:  $total_input_tokens"
  echo "Output tokens: $total_output_tokens"
  echo "Total tokens:  $((total_input_tokens + total_output_tokens))"

  local cost
  cost=$(calculate_cost "$total_input_tokens" "$total_output_tokens")
  echo "Est. cost:     \$$cost"

  if [[ ${#task_branches[@]} -gt 0 ]]; then
    echo ""
    echo "${BOLD}>>> Branches Created${RESET}"
    for branch in "${task_branches[@]}"; do
      echo "  - $branch"
    done
  fi

  echo "${BOLD}════════════════════════════════════════════════════════════${RESET}"
}

# ============================================
# HELP & VERSION
# ============================================

show_help() {
  cat << EOF
${BOLD}RALPH${RESET} - Autonomous AI Development Loop (v${VERSION})

${BOLD}USAGE:${RESET}
  ./ralph.sh [options]              # PRD mode (requires prd.json/PRD.md)
  ./ralph.sh "task description"     # Single task mode (brownfield)
  ./ralph.sh --init                 # Initialize .ralph/ config

${BOLD}CONFIG & SETUP:${RESET}
  --init              Initialize .ralph/ with smart defaults
  --config            Show current configuration

${BOLD}SINGLE TASK MODE:${RESET}
  "task description"  Run a single task (quotes required)
  --no-commit         Don't auto-commit after task

${BOLD}PRD LOOP MODE:${RESET}
  [N]                 Max iterations (default: unlimited)
  --prd FILE          PRD file path (default: auto-detect)
  --yaml FILE         Use YAML task file

${BOLD}WORKFLOW OPTIONS:${RESET}
  --no-tests          Skip running tests
  --no-lint           Skip linting
  --fast              Skip both tests and linting

${BOLD}EXECUTION OPTIONS:${RESET}
  --max-retries N     Max retries per task (default: 3)
  --retry-delay N     Seconds between retries (default: 5)
  --dry-run           Preview without executing

${BOLD}GIT BRANCH OPTIONS:${RESET}
  --branch-per-task   Create branch for each task
  --base-branch NAME  Base branch for PRs
  --create-pr         Create pull requests (requires gh CLI)
  --draft-pr          Create PRs as drafts

${BOLD}OTHER OPTIONS:${RESET}
  -v, --verbose       Show debug output
  -h, --help          Show this help
  --version           Show version

${BOLD}EXAMPLES:${RESET}
  ./ralph.sh --init                    # Initialize config
  ./ralph.sh "add dark mode toggle"    # Single task
  ./ralph.sh 20                        # Run 20 iterations
  ./ralph.sh --branch-per-task --create-pr  # Feature branch workflow

EOF
}

show_version() {
  echo "RALPH v${VERSION}"
}

# ============================================
# ARGUMENT PARSING
# ============================================

parse_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --no-tests|--skip-tests) SKIP_TESTS=true; shift ;;
      --no-lint|--skip-lint) SKIP_LINT=true; shift ;;
      --fast) SKIP_TESTS=true; SKIP_LINT=true; shift ;;
      --dry-run) DRY_RUN=true; shift ;;
      --max-retries) MAX_RETRIES="${2:-3}"; shift 2 ;;
      --retry-delay) RETRY_DELAY="${2:-5}"; shift 2 ;;
      --branch-per-task) BRANCH_PER_TASK=true; shift ;;
      --base-branch) BASE_BRANCH="${2:-}"; shift 2 ;;
      --create-pr) CREATE_PR=true; shift ;;
      --draft-pr) PR_DRAFT=true; shift ;;
      --prd) PRD_FILE="${2:-}"; PRD_SOURCE="auto"; shift 2 ;;
      --yaml) PRD_FILE="${2:-tasks.yaml}"; PRD_SOURCE="yaml"; shift 2 ;;
      -v|--verbose) VERBOSE=true; shift ;;
      -h|--help) show_help; exit 0 ;;
      --version) show_version; exit 0 ;;
      --init) INIT_MODE=true; shift ;;
      --config) SHOW_CONFIG=true; shift ;;
      --no-commit) AUTO_COMMIT=false; shift ;;
      -*)
        log_error "Unknown option: $1"
        echo "Use --help for usage"
        exit 1
        ;;
      *)
        # Check if it's a number (max iterations) or a task description
        if [[ "$1" =~ ^[0-9]+$ ]]; then
          MAX_ITERATIONS="$1"
        else
          SINGLE_TASK="$1"
        fi
        shift
        ;;
    esac
  done
}

# ============================================
# MAIN
# ============================================

main() {
  parse_args "$@"

  cd "$PROJECT_DIR"

  # Handle --init mode
  if [[ "$INIT_MODE" == true ]]; then
    init_ralph_config
    exit 0
  fi

  # Handle --config mode
  if [[ "$SHOW_CONFIG" == true ]]; then
    show_ralph_config
    exit 0
  fi

  # Handle single-task (brownfield) mode
  if [[ -n "$SINGLE_TASK" ]]; then
    # Check basic requirements
    if ! command -v claude &>/dev/null; then
      log_error "Claude Code CLI not found"
      log_info "Install: npm install -g @anthropic-ai/claude-code"
      exit 1
    fi

    run_brownfield_task "$SINGLE_TASK"
    exit $?
  fi

  # PRD mode
  echo ""
  echo "${BOLD}════════════════════════════════════════════════════════════${RESET}"
  echo "${BOLD}RALPH${RESET} - Autonomous AI Development Loop"
  echo "${BOLD}════════════════════════════════════════════════════════════${RESET}"

  # Check requirements
  if ! command -v claude &>/dev/null; then
    log_error "Claude Code CLI not found"
    log_info "Install: npm install -g @anthropic-ai/claude-code"
    exit 1
  fi

  if ! command -v jq &>/dev/null; then
    log_error "jq not found"
    log_info "Install: brew install jq / apt install jq"
    exit 1
  fi

  # Detect PRD source
  if [[ -z "$PRD_FILE" ]]; then
    detect_prd_source
  fi

  echo "  Engine: ${MAGENTA}Claude Code${RESET}"
  echo "  Source: ${CYAN}$PRD_SOURCE${RESET} ($PRD_FILE)"
  if [[ -d "$RALPH_DIR" ]]; then
    echo "  Config: ${GREEN}$RALPH_DIR/${RESET}"
  fi

  local mode_parts=()
  [[ "$SKIP_TESTS" == true ]] && mode_parts+=("no-tests")
  [[ "$SKIP_LINT" == true ]] && mode_parts+=("no-lint")
  [[ "$DRY_RUN" == true ]] && mode_parts+=("dry-run")
  [[ "$BRANCH_PER_TASK" == true ]] && mode_parts+=("branch-per-task")
  [[ $MAX_ITERATIONS -gt 0 ]] && mode_parts+=("max:$MAX_ITERATIONS")

  if [[ ${#mode_parts[@]} -gt 0 ]]; then
    echo "  Mode:   ${YELLOW}${mode_parts[*]}${RESET}"
  fi
  echo "${BOLD}════════════════════════════════════════════════════════════${RESET}"
  echo ""

  # Check remaining tasks
  local remaining
  remaining=$(count_remaining | tr -d '[:space:]')

  if [[ "$remaining" -eq 0 ]]; then
    log_success "All tasks already complete!"
    exit 0
  fi

  log_info "Starting with $remaining tasks remaining"

  # Main loop
  while true; do
    ((iteration++)) || true
    local result_code=0
    run_single_task "" "$iteration" || result_code=$?

    case $result_code in
      0) ;; # Success, continue
      1)
        log_warn "Task failed after $MAX_RETRIES attempts, continuing..."
        ;;
      2)
        # All tasks complete
        show_summary
        exit 0
        ;;
    esac

    # Check max iterations
    if [[ $MAX_ITERATIONS -gt 0 ]] && [[ $iteration -ge $MAX_ITERATIONS ]]; then
      log_warn "Reached max iterations ($MAX_ITERATIONS)"
      show_summary
      exit 0
    fi

    # Brief pause between iterations
    sleep 2
  done
}

# Run main
main "$@"
